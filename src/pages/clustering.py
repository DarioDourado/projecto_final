"""
P√°gina de Clustering DBSCAN
An√°lise de Segmenta√ß√£o baseada em Densidade
"""

import streamlit as st
import pandas as pd
import numpy as np
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import seaborn as sns
import matplotlib.pyplot as plt

def show_clustering_page(data):
    """P√°gina de clustering DBSCAN"""
    st.title("üéØ Clustering DBSCAN")
    st.markdown("### An√°lise de Segmenta√ß√£o baseada em Densidade")
    
    # Introdu√ß√£o contextual
    st.markdown("""
    <div style="
        background: linear-gradient(135deg, #f8f9fa, #e9ecef);
        padding: 1rem;
        border-radius: 8px;
        margin-bottom: 1.5rem;
        border-left: 4px solid #667eea;
    ">
        <p style="margin: 0; color: #495057;">
            üéØ <strong>DBSCAN (Density-Based Spatial Clustering)</strong> √© um algoritmo de clustering 
            que agrupa pontos densamente agrupados e marca pontos isolados como ru√≠do (outliers).
        </p>
    </div>
    """, unsafe_allow_html=True)
    
    if 'dbscan_results' not in data:
        show_no_clustering_data()
        return
    
    dbscan_df = data['dbscan_results']
    
    # Verificar se dados s√£o v√°lidos
    if dbscan_df.empty:
        st.warning("‚ö†Ô∏è Dataset de clustering vazio")
        return
    
    # An√°lise estat√≠stica dos clusters
    show_cluster_statistics(dbscan_df)
    
    # Visualiza√ß√µes dos clusters
    show_cluster_visualizations(dbscan_df)
    
    # An√°lise detalhada por cluster
    show_cluster_analysis(dbscan_df)
    
    # M√©tricas de qualidade
    show_clustering_metrics(dbscan_df)
    
    # Insights e recomenda√ß√µes
    show_clustering_insights(dbscan_df)

def show_no_clustering_data():
    """Mostrar aviso quando dados de clustering n√£o est√£o dispon√≠veis"""
    st.markdown("""
    <div style="
        background: linear-gradient(135deg, #fff3cd, #ffeaa7);
        padding: 2rem;
        border-radius: 12px;
        text-align: center;
        margin: 2rem 0;
        border: 1px solid #ffecb5;
    ">
        <div style="font-size: 3rem; margin-bottom: 1rem;">üéØ</div>
        <h3 style="color: #856404; margin-bottom: 1rem;">An√°lise DBSCAN N√£o Executada</h3>
        <p style="color: #856404; margin-bottom: 1.5rem;">
            Execute o pipeline completo para gerar os resultados de clustering.
        </p>
        <div style="
            background: rgba(133, 100, 4, 0.1);
            padding: 1rem;
            border-radius: 8px;
            font-family: monospace;
            color: #856404;
            font-weight: bold;
        ">
            python main.py
        </div>
    </div>
    """, unsafe_allow_html=True)
    
    # Informa√ß√µes sobre DBSCAN
    st.markdown("#### üìö Sobre o Algoritmo DBSCAN")
    
    col1, col2 = st.columns(2)
    
    with col1:
        st.markdown("""
        **üéØ Caracter√≠sticas:**
        - Baseado em densidade
        - Detecta clusters de forma arbitr√°ria
        - Identifica outliers automaticamente
        - N√£o requer n√∫mero de clusters predefinido
        """)
    
    with col2:
        st.markdown("""
        **‚öôÔ∏è Par√¢metros:**
        - **eps**: Dist√¢ncia m√°xima entre pontos
        - **min_samples**: N√∫mero m√≠nimo de pontos
        - **metric**: M√©trica de dist√¢ncia utilizada
        """)

def show_cluster_statistics(dbscan_df):
    """Mostrar estat√≠sticas dos clusters"""
    st.subheader("üìä Estat√≠sticas dos Clusters")
    
    if 'cluster' not in dbscan_df.columns:
        st.error("‚ùå Coluna 'cluster' n√£o encontrada nos dados")
        return
    
    cluster_counts = dbscan_df['cluster'].value_counts().sort_index()
    n_clusters = len(cluster_counts[cluster_counts.index != -1])
    noise_points = cluster_counts.get(-1, 0)
    total_points = len(dbscan_df)
    
    # Cards de m√©tricas principais
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        create_metric_card(
            "üéØ Clusters V√°lidos",
            n_clusters,
            "Grupos identificados",
            "#28a745"
        )
    
    with col2:
        create_metric_card(
            "üî¥ Pontos de Ru√≠do",
            noise_points,
            "Outliers detectados",
            "#dc3545"
        )
    
    with col3:
        noise_rate = (noise_points / total_points) * 100 if total_points > 0 else 0
        create_metric_card(
            "üìä Taxa de Ru√≠do",
            f"{noise_rate:.1f}%",
            "Percentual de outliers",
            "#ffc107"
        )
    
    with col4:
        avg_cluster_size = (total_points - noise_points) / n_clusters if n_clusters > 0 else 0
        create_metric_card(
            "üë• Tamanho M√©dio",
            f"{avg_cluster_size:.0f}",
            "Pontos por cluster",
            "#17a2b8"
        )

def create_metric_card(title, value, description, color):
    """Criar card de m√©trica estilizado"""
    st.markdown(f"""
    <div style="
        background: linear-gradient(135deg, {color}15, {color}08);
        padding: 1.5rem;
        border-radius: 12px;
        border-left: 4px solid {color};
        margin: 0.5rem 0;
        box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        text-align: center;
        min-height: 120px;
        display: flex;
        flex-direction: column;
        justify-content: center;
    ">
        <h4 style="margin: 0; color: #333; font-size: 0.9rem; font-weight: 600;">
            {title}
        </h4>
        <h2 style="margin: 0.8rem 0; color: {color}; font-size: 2rem; font-weight: bold;">
            {value}
        </h2>
        <p style="margin: 0; color: #666; font-size: 0.8rem; opacity: 0.8;">
            {description}
        </p>
    </div>
    """, unsafe_allow_html=True)

def show_cluster_visualizations(dbscan_df):
    """Mostrar visualiza√ß√µes dos clusters"""
    st.subheader("üìà Visualiza√ß√µes dos Clusters")
    
    cluster_counts = dbscan_df['cluster'].value_counts().sort_index()
    
    # Duas visualiza√ß√µes lado a lado
    col1, col2 = st.columns(2)
    
    with col1:
        # Gr√°fico de barras da distribui√ß√£o
        fig_bar = px.bar(
            x=cluster_counts.index,
            y=cluster_counts.values,
            title="Distribui√ß√£o dos Clusters",
            labels={'x': 'Cluster ID', 'y': 'N√∫mero de Pontos'},
            color=cluster_counts.index,
            color_continuous_scale='viridis'
        )
        
        # Destacar ru√≠do em vermelho
        fig_bar.update_traces(
            marker_color=['red' if x == -1 else f'rgba(68, 133, 244, 0.8)' 
                         for x in cluster_counts.index]
        )
        
        fig_bar.update_layout(
            height=400,
            showlegend=False,
            xaxis_title="Cluster ID (-1 = Ru√≠do)",
            yaxis_title="Quantidade de Pontos"
        )
        st.plotly_chart(fig_bar, use_container_width=True)
    
    with col2:
        # Gr√°fico de pizza (sem ru√≠do para melhor visualiza√ß√£o)
        valid_clusters = cluster_counts[cluster_counts.index != -1]
        
        if len(valid_clusters) > 0:
            fig_pie = px.pie(
                values=valid_clusters.values,
                names=[f'Cluster {i}' for i in valid_clusters.index],
                title="Propor√ß√£o dos Clusters V√°lidos"
            )
            fig_pie.update_layout(height=400)
            st.plotly_chart(fig_pie, use_container_width=True)
        else:
            st.warning("‚ö†Ô∏è Nenhum cluster v√°lido encontrado")
    
    # Visualiza√ß√£o 2D se houver colunas num√©ricas suficientes
    numeric_cols = dbscan_df.select_dtypes(include=[np.number]).columns.tolist()
    numeric_cols = [col for col in numeric_cols if col != 'cluster']
    
    if len(numeric_cols) >= 2:
        show_2d_cluster_plot(dbscan_df, numeric_cols)

def show_2d_cluster_plot(dbscan_df, numeric_cols):
    """Mostrar plot 2D dos clusters"""
    st.markdown("#### üìç Visualiza√ß√£o 2D dos Clusters")
    
    # Seletor de vari√°veis
    col1, col2 = st.columns(2)
    
    with col1:
        x_var = st.selectbox(
            "Vari√°vel X:",
            numeric_cols,
            key="cluster_x_var"
        )
    
    with col2:
        y_vars = [col for col in numeric_cols if col != x_var]
        if y_vars:
            y_var = st.selectbox(
                "Vari√°vel Y:",
                y_vars,
                key="cluster_y_var"
            )
        else:
            y_var = None
    
    if x_var and y_var:
        # Criar scatter plot
        fig_scatter = px.scatter(
            dbscan_df,
            x=x_var,
            y=y_var,
            color='cluster',
            title=f"Clusters: {y_var} vs {x_var}",
            color_continuous_scale='viridis',
            hover_data=['cluster']
        )
        
        # Personalizar cores para ru√≠do
        fig_scatter.update_traces(
            marker=dict(
                size=8,
                opacity=0.7,
                line=dict(width=1, color='white')
            )
        )
        
        fig_scatter.update_layout(
            height=500,
            xaxis_title=x_var.replace('_', ' ').title(),
            yaxis_title=y_var.replace('_', ' ').title()
        )
        
        st.plotly_chart(fig_scatter, use_container_width=True)

def show_cluster_analysis(dbscan_df):
    """An√°lise detalhada por cluster"""
    st.subheader("üîç An√°lise Detalhada por Cluster")
    
    cluster_counts = dbscan_df['cluster'].value_counts().sort_index()
    
    # Criar tabela de detalhes
    cluster_details = []
    for cluster_id in sorted(cluster_counts.index):
        cluster_data = dbscan_df[dbscan_df['cluster'] == cluster_id]
        
        detail = {
            'Cluster ID': cluster_id,
            'Tipo': 'Ru√≠do' if cluster_id == -1 else 'V√°lido',
            'Pontos': cluster_counts[cluster_id],
            'Percentual': f"{(cluster_counts[cluster_id] / len(dbscan_df)) * 100:.2f}%"
        }
        
        # Adicionar estat√≠sticas das colunas num√©ricas
        numeric_cols = cluster_data.select_dtypes(include=[np.number]).columns
        numeric_cols = [col for col in numeric_cols if col != 'cluster']
        
        if len(numeric_cols) > 0:
            for col in numeric_cols[:3]:  # Limitar a 3 colunas para n√£o sobrecarregar
                detail[f'{col}_mean'] = f"{cluster_data[col].mean():.2f}"
        
        cluster_details.append(detail)
    
    # Mostrar tabela
    details_df = pd.DataFrame(cluster_details)
    st.dataframe(details_df, use_container_width=True)
    
    # An√°lise individual dos clusters
    if len(cluster_counts) > 1:
        st.markdown("#### üìã Perfil dos Clusters")
        
        selected_cluster = st.selectbox(
            "Selecionar cluster para an√°lise detalhada:",
            sorted(cluster_counts.index),
            format_func=lambda x: f"Cluster {x}" if x != -1 else "Ru√≠do (Outliers)"
        )
        
        show_individual_cluster_analysis(dbscan_df, selected_cluster)

def show_individual_cluster_analysis(dbscan_df, cluster_id):
    """An√°lise individual de um cluster espec√≠fico"""
    cluster_data = dbscan_df[dbscan_df['cluster'] == cluster_id]
    
    col1, col2 = st.columns(2)
    
    with col1:
        st.markdown(f"**üìä Informa√ß√µes do {'Ru√≠do' if cluster_id == -1 else f'Cluster {cluster_id}'}:**")
        
        info = {
            "üî¢ Total de Pontos": len(cluster_data),
            "üìä % do Dataset": f"{(len(cluster_data) / len(dbscan_df)) * 100:.2f}%",
            "üéØ Densidade": "Baixa" if cluster_id == -1 else "Alta"
        }
        
        for key, value in info.items():
            st.write(f"- {key}: {value}")
    
    with col2:
        # Estat√≠sticas das colunas num√©ricas
        numeric_cols = cluster_data.select_dtypes(include=[np.number]).columns
        numeric_cols = [col for col in numeric_cols if col != 'cluster']
        
        if len(numeric_cols) > 0:
            st.markdown("**üìà Estat√≠sticas Num√©ricas:**")
            
            for col in numeric_cols[:3]:
                mean_val = cluster_data[col].mean()
                std_val = cluster_data[col].std()
                st.write(f"- {col}: Œº={mean_val:.2f}, œÉ={std_val:.2f}")

def show_clustering_metrics(dbscan_df):
    """Mostrar m√©tricas de qualidade do clustering"""
    st.subheader("üìè M√©tricas de Qualidade")
    
    try:
        from sklearn.metrics import silhouette_score, calinski_harabasz_score
        
        # Preparar dados para m√©tricas (apenas clusters v√°lidos)
        valid_data = dbscan_df[dbscan_df['cluster'] != -1]
        
        if len(valid_data) == 0:
            st.warning("‚ö†Ô∏è Nenhum cluster v√°lido para calcular m√©tricas")
            return
        
        numeric_cols = valid_data.select_dtypes(include=[np.number]).columns
        numeric_cols = [col for col in numeric_cols if col != 'cluster']
        
        if len(numeric_cols) < 2:
            st.warning("‚ö†Ô∏è Dados insuficientes para calcular m√©tricas de qualidade")
            return
        
        X = valid_data[numeric_cols]
        labels = valid_data['cluster']
        
        # Calcular m√©tricas
        if len(labels.unique()) > 1:
            silhouette = silhouette_score(X, labels)
            calinski = calinski_harabasz_score(X, labels)
            
            # Mostrar m√©tricas em cards
            col1, col2, col3 = st.columns(3)
            
            with col1:
                # Silhouette Score (-1 a 1, quanto maior melhor)
                silhouette_color = "#28a745" if silhouette > 0.5 else "#ffc107" if silhouette > 0.2 else "#dc3545"
                create_metric_card(
                    "üìä Silhouette Score",
                    f"{silhouette:.3f}",
                    "Qualidade da separa√ß√£o",
                    silhouette_color
                )
            
            with col2:
                # Calinski-Harabasz Score (quanto maior melhor)
                ch_color = "#28a745" if calinski > 100 else "#ffc107" if calinski > 50 else "#dc3545"
                create_metric_card(
                    "üìà Calinski-Harabasz",
                    f"{calinski:.1f}",
                    "Raz√£o vari√¢ncia inter/intra",
                    ch_color
                )
            
            with col3:
                # N√∫mero efetivo de clusters
                n_clusters = len(labels.unique())
                create_metric_card(
                    "üéØ Clusters Efetivos",
                    n_clusters,
                    "Grupos bem definidos",
                    "#17a2b8"
                )
    
    except ImportError:
        st.info("üì¶ Instale scikit-learn para m√©tricas avan√ßadas: `pip install scikit-learn`")

def show_clustering_insights(dbscan_df):
    """Mostrar insights e recomenda√ß√µes"""
    st.subheader("üí° Insights e Recomenda√ß√µes")
    
    cluster_counts = dbscan_df['cluster'].value_counts().sort_index()
    n_clusters = len(cluster_counts[cluster_counts.index != -1])
    noise_points = cluster_counts.get(-1, 0)
    total_points = len(dbscan_df)
    noise_rate = (noise_points / total_points) * 100
    
    insights = []
    
    # An√°lise do n√∫mero de clusters
    if n_clusters == 0:
        insights.append({
            "icon": "üî¥",
            "title": "Nenhum Cluster Identificado",
            "message": "Todos os pontos foram classificados como ru√≠do. Considere ajustar os par√¢metros eps e min_samples.",
            "type": "error"
        })
    elif n_clusters == 1:
        insights.append({
            "icon": "üü°",
            "title": "Cluster √önico Detectado",
            "message": "Apenas um cluster foi identificado. Os dados podem ser muito homog√™neos ou os par√¢metros muito restritivos.",
            "type": "warning"
        })
    elif 2 <= n_clusters <= 5:
        insights.append({
            "icon": "üü¢",
            "title": "Segmenta√ß√£o Adequada",
            "message": f"{n_clusters} clusters identificados. Boa segmenta√ß√£o para an√°lise e interpreta√ß√£o.",
            "type": "success"
        })
    else:
        insights.append({
            "icon": "üü°",
            "title": "Muitos Clusters Detectados",
            "message": f"{n_clusters} clusters podem indicar over-segmenta√ß√£o. Considere aumentar o par√¢metro eps.",
            "type": "warning"
        })
    
    # An√°lise da taxa de ru√≠do
    if noise_rate > 30:
        insights.append({
            "icon": "üî¥",
            "title": "Alta Taxa de Ru√≠do",
            "message": f"{noise_rate:.1f}% dos pontos s√£o outliers. Par√¢metros podem estar muito restritivos.",
            "type": "error"
        })
    elif noise_rate > 15:
        insights.append({
            "icon": "üü°",
            "title": "Taxa de Ru√≠do Moderada",
            "message": f"{noise_rate:.1f}% de outliers detectados. Monitore a qualidade da segmenta√ß√£o.",
            "type": "warning"
        })
    else:
        insights.append({
            "icon": "üü¢",
            "title": "Taxa de Ru√≠do Controlada",
            "message": f"Apenas {noise_rate:.1f}% de outliers. Boa detec√ß√£o de densidade.",
            "type": "success"
        })
    
    # Mostrar insights
    for insight in insights:
        bg_color = {
            "success": "#d4edda",
            "warning": "#fff3cd", 
            "error": "#f8d7da"
        }.get(insight["type"], "#e9ecef")
        
        border_color = {
            "success": "#28a745",
            "warning": "#ffc107",
            "error": "#dc3545"
        }.get(insight["type"], "#6c757d")
        
        st.markdown(f"""
        <div style="
            background: {bg_color};
            padding: 1.2rem;
            border-radius: 10px;
            border-left: 4px solid {border_color};
            margin: 1rem 0;
            display: flex;
            align-items: flex-start;
        ">
            <div style="font-size: 1.5rem; margin-right: 1rem; margin-top: 0.2rem;">
                {insight['icon']}
            </div>
            <div>
                <h4 style="margin: 0 0 0.5rem 0; color: #333;">
                    {insight['title']}
                </h4>
                <p style="margin: 0; color: #555; line-height: 1.5;">
                    {insight['message']}
                </p>
            </div>
        </div>
        """, unsafe_allow_html=True)
    
    # Recomenda√ß√µes t√©cnicas
    st.markdown("#### üîß Recomenda√ß√µes T√©cnicas")
    
    recommendations = [
        "üéØ **Ajuste de Par√¢metros**: Experimente diferentes valores de eps e min_samples",
        "üìä **Valida√ß√£o**: Use m√©tricas como Silhouette Score para avaliar qualidade",
        "üîç **An√°lise de Outliers**: Investigue os pontos classificados como ru√≠do",
        "üìà **Interpreta√ß√£o**: Analise as caracter√≠sticas de cada cluster identificado"
    ]
    
    for rec in recommendations:
        st.markdown(f"- {rec}")